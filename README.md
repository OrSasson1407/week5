הסבר שאלה 3

הקוד מריץ שני תהליכונים, המגדילים יחד מונה משותף bar ל-20,000.

הפעולה bar++ היא לא שלמה. היא מורכבת מקריאה, שינוי וכתיבה. כאשר התהליכונים עובדים במקביל, הם עלולים לדרוס את העדכונים של השני, ולכן התוצאה לרוב תהיה שגויה, כלומר פחות מ-20,000.

הסבר שאלה 4

הקוד עכשיו משתמש במילת המפתח "מסונכרן" בשתי המתודות.

משמעות הדבר היא שברגע שתהליכון אחד נכנס למתודה המסומנת, הוא נועל את כל האובייקט. אף תהליכון אחר לא יכול להיכנס לשום מתודה מסונכרנת באותו אובייקט עד שהתהליכון הראשון יסיים וישחרר את הנעילה.

הסבר שאלה 5

בשאלה זו נעשה שימוש בבלוק synchronized(this) בתוך המתודה baz במקום לסנכרן את כל המתודה.

גם כאן, ברגע שתהליכון אחד נכנס לבלוק המסונכרן, הוא נועל את האובייקט (this), ולכן תהליכון אחר לא יכול להיכנס לאותו קטע קוד במקביל. כך נמנעת דריסה של הערך bar והפעולה bar++ מתבצעת בצורה בטוחה.

התוצאה הסופית תהיה נכונה ועקבית – 20,000 בכל הרצה, משום שלא מתרחשים מצבי race condition.

ההבדל העיקרי לעומת שאלה 4 הוא שכאן רק קטע קוד מסוים מוגן בנעילה, ולא כל המתודה, מה שמאפשר גמישות ושליטה טובה יותר על אזור הסנכרון.