הסבר שאלה 3

הקוד מריץ שני תהליכונים, המגדילים יחד מונה משותף bar ל-20,000.

הפעולה bar++ היא לא שלמה. היא מורכבת מקריאה, שינוי וכתיבה. כאשר התהליכונים עובדים במקביל, הם עלולים לדרוס את העדכונים של השני, ולכן התוצאה לרוב תהיה שגויה, כלומר פחות מ-20,000.

הסבר שאלה 4

הקוד עכשיו משתמש במילת המפתח "מסונכרן" בשתי המתודות.

משמעות הדבר היא שברגע שתהליכון אחד נכנס למתודה המסומנת, הוא נועל את כל האובייקט. אף תהליכון אחר לא יכול להיכנס לשום מתודה מסונכרנת באותו אובייקט עד שהתהליכון הראשון יסיים וישחרר את הנעילה.

הסבר שאלה 5

בשאלה זו נעשה שימוש בבלוק synchronized(this) בתוך המתודה baz במקום לסנכרן את כל המתודה.

גם כאן, ברגע שתהליכון אחד נכנס לבלוק המסונכרן, הוא נועל את האובייקט (this), ולכן תהליכון אחר לא יכול להיכנס לאותו קטע קוד במקביל. כך נמנעת דריסה של הערך bar והפעולה bar++ מתבצעת בצורה בטוחה.

התוצאה הסופית תהיה נכונה ועקבית – 20,000 בכל הרצה, משום שלא מתרחשים מצבי race condition.

ההבדל העיקרי לעומת שאלה 4 הוא שכאן רק קטע קוד מסוים מוגן בנעילה, ולא כל המתודה, מה שמאפשר גמישות ושליטה טובה יותר על אזור הסנכרון.

הסבר שאלה 6 

בשאלה זו הוסר מנגנון הסנכרון לחלוטין והמטרה היא להדגים את השפעתו על הביצועים. הקוד מריץ עשרה תהליכונים שמבצעים יחד 100,000,000 פעולות הגדלה של המשתנה bar.

למרות שזמן הריצה קצר יותר, הערך הסופי של bar שגוי ונמוך מהערך הצפוי, מכיוון שהפעולה bar++ אינה אטומית ועדכונים נדרסים בין תהליכונים.

המסקנה היא ששימוש ללא synchronized משפר ביצועים אך פוגע בדיוק התוצאה.

הסבר שאלה 7

הוחזר מנגנון synchronized לפעולת ההגדלה.

התוצאה כעת מדויקת, אך זמן הריצה ארוך יותר בשל ההמתנה בין התהליכונים לנעילה.